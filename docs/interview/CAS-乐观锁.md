CAS 是项乐观锁技术，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查 + 数据更新的原理是一样的。

java.util.concurrent 包完全建立在 CAS 之上，没有 CAS 就不会有此包。可见 CAS 的重要性。

## CAS

CAS：Compare and Swap，翻译为：比较并交换

java.util.concurrent 包中借助 CAS 实现了区别于 synchronouse 同步锁的一种乐观锁。

## CAS 应用

> CAS 有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

**非阻塞算法 （nonblocking algorithms）**

> 一个线程的失败或者挂起不应该影响其他线程的失败或者挂起的算法。

现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。

​	拿出 AtomicInteger 来研究在没有锁的情况下是如何做到数据正确性的。

```java
private volatile int value;
```

毫无疑问，在没有锁的机制下需要借助 volatile 关键字，保证线程间的数据是可见的（共享的）。这样获取变量的值的时候才能直接读取。

```java
public final int get() {
    return value;
}
```

然后：

```java

```

