CAS 会导致“ABA问题”。

CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。

比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。

部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。

### 解决方案

1. AtomicStampedReference

   本质是有一个 int 值作为版本号，每次更新前先取得这个 int 值的版本号，等到修改的时候，比较当前版本号与当前线程持有的版本号是否一致，如果一致，则进行修改，并将版本号 + 1（n），在 zookeeper 中保持数据的一致性也是用的这种方式；

2. AtomicMarkableReference

   是将一个 Boolean 值作为是否有更改的标记，本质就是他的版本号只有两个，true 和 false，修改的时候在这两个版本号之间来回切换，这样做并不能解决 ABA 问题，只是会降低 ABA 问题发生的机率而已。

