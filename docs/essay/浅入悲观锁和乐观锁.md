稍带记录一些悲观锁和乐观锁的概念以及区别。主要代表是 synchronized 和 CAS 的区别

## 悲观锁

悲观锁 是一种 **独占锁**，它假设的前提是 “冲突一定会发生” ，所以处理某段可能出现数据冲突的代码时，这个代码段就要被某个线程独占。而 **独占** 意味着 “其它即将执行这段代码的其他线程” 都将进入“阻塞”/“挂起” 状态。

synchronized 关键字就是 java 对于悲观锁的实现。

由于悲观锁的影响下，其他线程都将进入 阻塞/挂起 状态。而我们知道，CPU执行线程状态切换是要耗费相当资源的，这主要涉及到 CPU 寄存器的操作。所以悲观锁在性能上不会有太多惊艳的表现（但是一般也不至于成为性能瓶颈，万事无绝对）

## 乐观锁

乐观锁假定 “冲突不一定会出现”， 如果出现冲突则进行重试，直到冲突消失。由于乐观锁的假定条件，所以乐观锁不会独占资源，性能自然在 **多数情况下** 好于悲观锁。

AtomicInteger是一个标准的乐观锁实现，sun.misc.Unsafe是JDK提供的乐观锁的支持。

```java
public final long getAndAddLong(Object var1, long var2, long var4) {
    long var6;
    do {
        var6 = this.getLongVolatile(var1, var2);
    } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));

    return var6;
}
```

为什么是多数情况呢？因为一旦多线程对某个资源的抢占频度达到了某种规模，就会导致乐观锁内部出现多次更新失败的情况，最终造成乐观锁内部进入一种“活锁”状态。这时乐观锁的性能反而没有悲观锁好。