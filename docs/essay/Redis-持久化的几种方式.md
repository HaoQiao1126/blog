> Redis 必须使用数据持久化吗？如果 Redis 服务器只作为缓存使用, Redis 中存储的所有数据都是从其他地方同步过来的备份,那么就没必要开启数据持久化的选项.

- Redis 提供了将数据定期自动持久化至硬盘的能力,包括 RDB 和 AOF 两种方案,两种方案分别有其长处和短板,可以配合起来同时运行,确保数据的稳定性.

​	

## RDB(Redis DataBase) : 快照存储

![RDB](assets/RDB.png)

RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘(一个RDB临时文件中).

redis 默认开启 RDB 快照!

#### 机制:

- fork 出一个子进程,专门进行数据持久化,将内存中所有数据保存到单个 rdb 文件中(默认为 dump.rdb)
- redis 重启后,会加载 rdb 文件中的数据到内存中

#### 触发方式:

- 配置中设置持久化策略
- SAVE|BGSAVE(手动触发)|SHUTDOWN (前提是设置了自动持久化策略)

#### 配置:

------save [seconds] [changes]  意为在 [seconds] 秒内如果发生了 [changes] 次数据修改,则进行一次 RDB 快照保存

- save 60 1000  # 60秒内如果发生了1000次或以上的数据变更,则持久化一次(dump 内存快照)
- stop-writes-on-bgsave-error  no  # 创建快照失败后,是否继续执行写命令
- rdbcompression  yes  # 是否对快照文件进行压缩
- dbfilename dump.rdb  # 快照文件命名
- dir  ./  # 快照文件保存的位置
- save # 关闭 RDB 机制

#### 优点:

- 对性能影响最小. redis 在保存 RDB 快照时会 fork 出子进程进行,几乎不影响 redis 处理客户端请求的效率.
- 方便数据备份. 由于保存到单独的文件中,易于数据备份(可以使用定时任务,定时将文件发送给数据备份中心)
- 恢复大量数据时,速度优于 AOF

#### 缺点:

- 不是实时保存数据, 如果 redis 意外停止工作(断电等), 则可能会丢失一段时间的数据.
- 数据量大时, fork 进程会比较慢, 持久化时使 redis 响应速度变慢,影响对外提供服务的能力.

## AOF (Append-Only File) : 只追加文件

![AOF](assets/AOF.png)

采用 AOF 持久方式时, redis 会把每一个写请求都记录在一个日志文件里. 在 Redis 重启时,会把 AOF 文件中记录的所有写操作顺序执行一遍,确保数据恢复到最新.

#### 机制:

- 如果同时开启了 RDB, 则优先使用 AOF
- 主线程将`写命令`追加到 AOF_BUF(缓存区) 中,根据使用的策略不同, 子线程 将缓存区的命令写入到 AOF 文件中(不使用子线程)
- 当 redis 重启时,会重新执行 AOF 文件中的命令来恢复数据
- AOF 默认是关闭的, 如要开启, 进行如下配置:
  - appendonly  yes

####  使用策略:

​	AOF 提供了三种 fsync(同步) 配置, always/everysec/no, 通过配置项 [appendfsync] 指定:

- appendfsync  no: 不进行 fsync, 将 flush 文件的时间交给 OS 决定,速度最快

- appendfsync  always:  每写入一条日志就进行一次 fsync 操作, 数据安全性最高,但速度最慢

- appendfsync  everysec:  折中的做法, 交由后台线程每秒 fsync 一次

  随着 AOF 不断的记录写操作日志,因为所有的操作都会记录,所以必定出现一些无用的日志.大量无用的日志会让 AOF 文件过大,也会让数据恢复的时间过长.不过 Redis 提供了 AOF rewrite 功能,可以重写 AOF 文件,只保留能够把数据恢复到最新状态的最小写操作集.

  - AOF rewrite 同 RDB 一样,都需要 Redis 主进程进行 fork 操作. fork 操作本身可能会产生较高的耗时,与 CPU 和 Redis 占用的内存大小有关. 根据具体的情况合理配置 RDB 快照和 AOF Rewrite 时机,避免过于频繁的 fork 带来的延迟

  - AOF rewrite 可以通过 `BGREWRITEAOF` 命令触发,也可以配置 Redis 定期自动进行:

    ```shell
    auto-aof-rewrite-percentage  100
    auto-aof-rewrite-min-size   64mb
    ```
    这两个配置的含义是: Redis 在每次 AOF rewrite 时, 会记录完成 rewrite 后的 AOF 日志大小,当 AOF 日志大小在该基础上增长了 100 % 后,自动进行 AOF rewrite. 同时如果增长的大小没有达到 64mb,则不会进行 rewrite.

#### 相关配置:

- appendonly  no  # 是否开启 AOF 机制
- appendfsync  everysec  # 多久将写入的内容同步到磁盘, [每秒一次]
- no-appendfsync-onrewrite  no  # 重写 aof 文件时是否执行同步操作
- appendfilename  appendonly.aof  #  aof 文件名
- dir  ./  # AOF 文件保存的位置(和 RDB 文件共享该配置)

#### 文件修复:

- 首先备份 AOF 文件
- 使用 redis-check-aof 工具进行修复(一般会删除末尾无法恢复的命令)
  - 修复步骤: $ redis-check-aof -fix
  - 可使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份,查看两个文件的不同之处.
- 重启 redis 服务器,自动载入修复后的 AOF 文件,进行数据恢复
- 如果 AOF 出错(磁盘满了/写入中途宕机等), 则 redis 重启时会拒绝使用该 AOF 文件

#### 优点:

- 安全. 在启用 appendfsync  always 时, 任何已写入的数据都不会丢失, 使用在启用 appendfsync  everysec 也至多只会丢失 1s 的数据.
- 可靠. AOF 文件在发生断电等问题时也不会损坏,即使出现了某条日志只写入了一半的情况,也可以使用 redis-check-aof 工具轻松修复
- AOF 文件易读, 可修改, 在进行了某些错误的数据清除操作后,只要AOF 文件没有 rewrite,就可以把 AOF 文件备份出来, 把错误的命令删除,然后恢复数据.

#### 缺点:

- AOF 文件通常比 RDB 文件更大
- 性能消耗比 RDB 高
- 数据恢复速度比 RDB 慢

## 二者优缺点

#### RDB 优势:

- 一旦采用该方式 ，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数 据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。 
-  对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。 
-  性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。 
-  相比于AOF机制，如果数据集很大，RDB的启动效率会更高。 

#### RDB 劣势:

-  如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。 
-  由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。 

#### AOF 优势:

-  该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其 效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变 化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。 
-  由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操 作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据 一致性的问题。 
-  如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创 建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。 
-  AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。 

#### AOF 劣势:

-  对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 
-  根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。 

## 总结:

​	 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。 

​	 大多数应用场景下，建议至少开启RDB方式的数据持久化。Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。 

	- 数据安全性要求高,都打开
	- 可以接受短时间的数据丢失,只使用 RDB
	- 即使使用 AOF, 最好也开启 RDB, 因为便于备份并且恢复速度快, bug 更少